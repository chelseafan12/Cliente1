"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Poll = exports.PollOption = exports.PollAnswer = void 0;
const platform_node_js_1 = require("../../../platform.node.js");
const TL_js_1 = require("../../TL.js");
const index_js_1 = require("../../Advanced/index.js");
const Utilities_js_1 = require("../../../Utilities.js");
class PollAnswer extends TL_js_1.TLObject {
    pollId;
    voterChat;
    user;
    options;
    constructor({ pollId, voterChat, user, options, }, client) {
        super(client);
        this.pollId = pollId;
        this.voterChat = voterChat;
        this.user = user;
        this.options = options;
    }
    static parseUpdate(client, vote, chats, users) {
        const userId = (0, Utilities_js_1.getId)(vote.peer);
        let from = index_js_1.User.parse(client, users.find((user) => user.id === userId));
        let chat = index_js_1.Chat.parseDialog(client, vote.peer, users, chats);
        return new PollAnswer({
            pollId: vote.pollId,
            options: vote.options.map((el) => el.toString()),
            user: from,
            voterChat: from ? undefined : chat,
        }, client);
    }
}
exports.PollAnswer = PollAnswer;
class PollOption extends TL_js_1.TLObject {
    text;
    chosen;
    correct;
    voters;
    option;
    entities;
    constructor({ text, chosen, correct, voters, option, entities, }, client) {
        super(client);
        this.text = text;
        this.chosen = chosen;
        this.correct = correct;
        this.voters = voters;
        this.option = option;
        this.entities = entities;
    }
}
exports.PollOption = PollOption;
class Poll extends TL_js_1.TLObject {
    id;
    closed;
    publicVoters;
    multipleChoice;
    quiz;
    question;
    questionEntities;
    options;
    min;
    totalVoters;
    recentVoters;
    closePeriod;
    closeDate;
    solution;
    solutionEntities;
    constructor({ id, closed, publicVoters, multipleChoice, quiz, question, questionEntities, options, closePeriod, closeDate, min, totalVoters, recentVoters, solution, solutionEntities, }, client) {
        super(client);
        this.id = id;
        this.closed = closed;
        this.publicVoters = publicVoters;
        this.multipleChoice = multipleChoice;
        this.quiz = quiz;
        this.question = question;
        this.questionEntities = questionEntities;
        this.options = options;
        this.closePeriod = closePeriod;
        this.closeDate = closeDate;
        this.min = min;
        this.totalVoters = totalVoters;
        this.recentVoters = recentVoters;
        this.solution = solution;
        this.solutionEntities = solutionEntities;
    }
    static parse(client, poll) {
        if (poll.poll) {
            return new Poll({
                id: poll.poll.id,
                closed: poll.poll.closed ?? false,
                publicVoters: poll.poll.publicVoters ?? false,
                multipleChoice: poll.poll.multipleChoice ?? false,
                quiz: poll.poll.quiz ?? false,
                question: poll.poll.question.text,
                questionEntities: platform_node_js_1.Parser.fromRaw(poll.poll.question.entities ?? []),
                options: poll.poll.answers.map((element, index) => {
                    if (poll.results?.results) {
                        const results = poll.results.results[index];
                        if (element && results) {
                            return new PollOption({
                                text: element.text.text,
                                chosen: results.chosen ?? false,
                                correct: results.correct ?? false,
                                voters: results.voters ?? 0,
                                option: element.option.toString('utf8'),
                                entities: platform_node_js_1.Parser.fromRaw(element.text.entities ?? []),
                            }, client);
                        }
                    }
                }),
                closePeriod: poll.poll.closePeriod ?? undefined,
                closeDate: poll.poll.closeDate ? new Date(poll.poll.closeDate * 1000) : undefined,
                min: poll.results.min ?? false,
                totalVoters: poll.results.totalVoters ?? 0,
                recentVoters: poll.results.recentVoters,
                solution: poll.results.solution,
                solutionEntities: platform_node_js_1.Parser.fromRaw(poll.results.solutionEntities ?? []),
            }, client);
        }
        return undefined;
    }
}
exports.Poll = Poll;
