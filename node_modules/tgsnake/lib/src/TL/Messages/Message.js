"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Message = void 0;
const TL_js_1 = require("../TL.js");
const platform_node_js_1 = require("../../platform.node.js");
const Advanceds = __importStar(require("../Advanced/index.js"));
const Medias = __importStar(require("./Medias/index.js"));
const ReplyMarkup = __importStar(require("./ReplyMarkup.js"));
const Utilities_js_1 = require("../../Utilities.js");
const Logger_js_1 = require("../../Context/Logger.js");
class Message extends TL_js_1.TLObject {
    id;
    outgoing;
    date;
    chat;
    from;
    threadId;
    senderChat;
    forwardFrom;
    forwardFromChat;
    forwardFromMessageId;
    forwardSignature;
    forwardSenderName;
    forwardDate;
    isTopicMessage;
    isAutomaticForward;
    replyToMessage;
    replyToMessageId;
    replyToTopMessageId;
    mentioned;
    empty;
    viaBot;
    hasProtectedContent;
    mediaGroupId;
    authorSignatrure;
    text;
    entities;
    animation;
    audio;
    document;
    photo;
    sticker;
    video;
    videoNote;
    voice;
    caption;
    captionEntities;
    hasSpoilerMode;
    contact;
    dice;
    game;
    poll;
    venue;
    location;
    webpage;
    newChatMembers;
    leftChatMember;
    newChatTitle;
    newChatPhoto;
    deleteChatPhoto;
    groupChatCreated;
    channelChatCreated;
    messageAutoDeleteTimeChanged;
    migrateToChatId;
    migrateFromChatId;
    pinnedMessage;
    invoice;
    successfulPayment;
    userShared;
    chatShared;
    connectedWebsite;
    writeAccessAllowed;
    passportData;
    forumTopicCreated;
    forumTopicEdited;
    videoChatScheduled;
    videoChatEnded;
    videoChatStarted;
    videoChatParticipantInvalid;
    videoChatInvited;
    webAppData;
    replyMarkup;
    giftPremium;
    chatThemeChanged;
    screenshot;
    ttl;
    replyToStoryId;
    repliedStoryFrom;
    linkPreviewOptions;
    constructor({ id, outgoing, date, chat, from, threadId, senderChat, forwardFrom, forwardFromChat, forwardFromMessageId, forwardSignature, forwardSenderName, forwardDate, isTopicMessage, isAutomaticForward, replyToMessage, replyToMessageId, replyToTopMessageId, mentioned, empty, viaBot, hasProtectedContent, mediaGroupId, authorSignatrure, text, entities, animation, audio, document, photo, sticker, video, videoNote, voice, webpage, caption, captionEntities, hasSpoilerMode, contact, dice, game, poll, venue, location, newChatMembers, leftChatMember, newChatTitle, newChatPhoto, deleteChatPhoto, groupChatCreated, channelChatCreated, messageAutoDeleteTimeChanged, migrateToChatId, migrateFromChatId, pinnedMessage, invoice, successfulPayment, userShared, chatShared, connectedWebsite, writeAccessAllowed, passportData, forumTopicCreated, forumTopicEdited, videoChatScheduled, videoChatEnded, videoChatStarted, videoChatParticipantInvalid, videoChatInvited, webAppData, replyMarkup, giftPremium, chatThemeChanged, screenshot, ttl, replyToStoryId, repliedStoryFrom, linkPreviewOptions, }, client) {
        super(client);
        this.id = id;
        this.outgoing = outgoing;
        this.date = date;
        this.chat = chat;
        this.from = from;
        this.threadId = threadId;
        this.senderChat = senderChat;
        this.forwardFrom = forwardFrom;
        this.forwardFromChat = forwardFromChat;
        this.forwardFromMessageId = forwardFromMessageId;
        this.forwardSignature = forwardSignature;
        this.forwardSenderName = forwardSenderName;
        this.forwardDate = forwardDate;
        this.isTopicMessage = isTopicMessage;
        this.isAutomaticForward = isAutomaticForward;
        this.replyToMessage = replyToMessage;
        this.replyToMessageId = replyToMessageId;
        this.replyToTopMessageId = replyToTopMessageId;
        this.mentioned = mentioned;
        this.empty = empty;
        this.viaBot = viaBot;
        this.hasProtectedContent = hasProtectedContent;
        this.mediaGroupId = mediaGroupId;
        this.authorSignatrure = authorSignatrure;
        this.text = text;
        this.entities = entities;
        this.animation = animation;
        this.audio = audio;
        this.document = document;
        this.photo = photo;
        this.sticker = sticker;
        this.video = video;
        this.videoNote = videoNote;
        this.voice = voice;
        this.webpage = webpage;
        this.caption = caption;
        this.captionEntities = captionEntities;
        this.hasSpoilerMode = hasSpoilerMode;
        this.contact = contact;
        this.dice = dice;
        this.game = game;
        this.poll = poll;
        this.venue = venue;
        this.location = location;
        this.newChatMembers = newChatMembers;
        this.leftChatMember = leftChatMember;
        this.newChatTitle = newChatTitle;
        this.newChatPhoto = newChatPhoto;
        this.deleteChatPhoto = deleteChatPhoto;
        this.groupChatCreated = groupChatCreated;
        this.channelChatCreated = channelChatCreated;
        this.messageAutoDeleteTimeChanged = messageAutoDeleteTimeChanged;
        this.migrateToChatId = migrateToChatId;
        this.migrateFromChatId = migrateFromChatId;
        this.pinnedMessage = pinnedMessage;
        this.invoice = invoice;
        this.successfulPayment = successfulPayment;
        this.userShared = userShared;
        this.chatShared = chatShared;
        this.connectedWebsite = connectedWebsite;
        this.writeAccessAllowed = writeAccessAllowed;
        this.passportData = passportData;
        this.forumTopicCreated = forumTopicCreated;
        this.forumTopicEdited = forumTopicEdited;
        this.videoChatScheduled = videoChatScheduled;
        this.videoChatEnded = videoChatEnded;
        this.videoChatStarted = videoChatStarted;
        this.videoChatParticipantInvalid = videoChatParticipantInvalid;
        this.videoChatInvited = videoChatInvited;
        this.webAppData = webAppData;
        this.replyMarkup = replyMarkup;
        this.giftPremium = giftPremium;
        this.chatThemeChanged = chatThemeChanged;
        this.screenshot = screenshot;
        this.ttl = ttl;
        this.replyToStoryId = replyToStoryId;
        this.repliedStoryFrom = repliedStoryFrom;
        this.linkPreviewOptions = linkPreviewOptions;
    }
    static async parse(client, message, chats, users, replies = 1) {
        if (!(message instanceof platform_node_js_1.Raw.MessageEmpty)) {
            const fromId = (0, Utilities_js_1.getId)(message.fromId);
            const peerId = (0, Utilities_js_1.getId)(message.peerId);
            const userId = fromId ?? peerId;
            if (message.fromId &&
                message.fromId instanceof platform_node_js_1.Raw.PeerUser &&
                message.peerId instanceof platform_node_js_1.Raw.PeerUser) {
                let hasFromId = users.some((user) => fromId === user.id);
                let hasPeerId = users.some((user) => peerId === user.id);
                if (!hasFromId || !hasPeerId) {
                    let user = await client._client.invoke(new platform_node_js_1.Raw.users.GetUsers({
                        id: [
                            await client._client.resolvePeer(fromId),
                            await client._client.resolvePeer(peerId),
                        ],
                    }));
                    users = users.concat(user);
                }
            }
            if (message instanceof platform_node_js_1.Raw.MessageService) {
                message;
                let from = Advanceds.User.parse(client, users.find((user) => user.id === userId));
                let senderChat = from
                    ? undefined
                    : Advanceds.Chat.parseMessage(client, message, users, chats, false);
                let chat = Advanceds.Chat.parseMessage(client, message, users, chats, true);
                let parsedMessage = new Message({
                    from,
                    senderChat,
                    chat,
                    outgoing: message.out,
                    id: message.id,
                    empty: false,
                    date: new Date(message.date * 1000),
                    mentioned: message.mentioned,
                }, client);
                if (message.action) {
                    const action = message.action;
                    if (action instanceof platform_node_js_1.Raw.MessageActionChatCreate) {
                        parsedMessage.groupChatCreated = true;
                    }
                    else if (action instanceof platform_node_js_1.Raw.MessageActionChatEditTitle) {
                        parsedMessage.newChatTitle = action.title;
                    }
                    else if (action instanceof platform_node_js_1.Raw.MessageActionChatEditPhoto) {
                        if (action.photo instanceof platform_node_js_1.Raw.Photo) {
                            parsedMessage.newChatPhoto = Medias.Photo.parse(client, action.photo);
                        }
                    }
                    else if (action instanceof platform_node_js_1.Raw.MessageActionChatDeletePhoto) {
                        parsedMessage.deleteChatPhoto = true;
                    }
                    else if (action instanceof platform_node_js_1.Raw.MessageActionChatAddUser) {
                        parsedMessage.newChatMembers = action.users
                            .map((id) => Advanceds.User.parse(client, users.find((u) => u.id === id)))
                            .filter((u) => u !== undefined);
                    }
                    else if (action instanceof platform_node_js_1.Raw.MessageActionChatDeleteUser) {
                        parsedMessage.leftChatMember = Advanceds.User.parse(client, users.find((u) => u.id === action.userId));
                    }
                    else if (action instanceof platform_node_js_1.Raw.MessageActionChatJoinedByLink) {
                        parsedMessage.newChatMembers = [
                            Advanceds.User.parse(client, users.find((u) => u.id === (0, Utilities_js_1.getId)(message.fromId))),
                        ].filter((u) => u !== undefined);
                    }
                    else if (action instanceof platform_node_js_1.Raw.MessageActionChannelCreate) {
                        parsedMessage.channelChatCreated = true;
                    }
                    else if (action instanceof platform_node_js_1.Raw.MessageActionChatMigrateTo) {
                        parsedMessage.migrateToChatId = action.channelId;
                    }
                    else if (action instanceof platform_node_js_1.Raw.MessageActionGroupCall) {
                        if (action.duration) {
                            parsedMessage.videoChatEnded = action.duration;
                        }
                        else {
                            parsedMessage.videoChatStarted = true;
                        }
                    }
                    else if (action instanceof platform_node_js_1.Raw.MessageActionInviteToGroupCall) {
                        parsedMessage.videoChatInvited = action.users
                            .map((id) => Advanceds.User.parse(client, users.find((u) => u.id === id)))
                            .filter((u) => u !== undefined);
                    }
                    else if (action instanceof platform_node_js_1.Raw.MessageActionGroupCallScheduled) {
                        parsedMessage.videoChatScheduled = new Date(action.scheduleDate * 1000);
                    }
                    else if (action instanceof platform_node_js_1.Raw.MessageActionChannelMigrateFrom) {
                        parsedMessage.migrateFromChatId = action.chatId;
                    }
                    else if (action instanceof platform_node_js_1.Raw.MessageActionPinMessage) {
                        try {
                            parsedMessage.pinnedMessage = (await client.api.getMessages(parsedMessage.chat?.id, [], [message.id], 0))[0];
                        }
                        catch (error) { }
                    }
                    else if (action instanceof platform_node_js_1.Raw.MessageActionTopicCreate) {
                        parsedMessage.forumTopicCreated = action;
                    }
                    else if (action instanceof platform_node_js_1.Raw.MessageActionTopicEdit) {
                        parsedMessage.forumTopicEdited = action;
                    }
                }
                if (message.replyTo) {
                    if (message.replyTo instanceof platform_node_js_1.Raw.MessageReplyHeader) {
                        parsedMessage.isTopicMessage =
                            message.replyTo?.forumTopic ?? false;
                        parsedMessage.replyToMessageId = message.replyTo?.replyToMsgId;
                        parsedMessage.replyToTopMessageId = message.replyTo?.replyToTopId;
                        if (replies) {
                            let cchat = client._cacheMessage.get(parsedMessage.chat?.id);
                            if (cchat) {
                                let cmsg = cchat.get(parsedMessage?.replyToMessageId);
                                if (cmsg) {
                                    parsedMessage.replyToMessage = cmsg;
                                }
                                else {
                                    try {
                                        let fmsg = await client.api.getMessages(parsedMessage.chat?.id, [], [message.id], replies - 1);
                                        parsedMessage.replyToMessage = fmsg[0];
                                    }
                                    catch (error) { }
                                }
                            }
                        }
                    }
                }
                if (message.ttlPeriod) {
                    parsedMessage.ttl = message.ttlPeriod;
                }
                return parsedMessage;
            }
            if (message instanceof platform_node_js_1.Raw.Message) {
                message;
                let entities = platform_node_js_1.Parser.fromRaw(message.entities ?? []).sort((a, b) => a.offset - b.offset);
                let forwardFrom;
                let forwardFromChat;
                let forwardFromMessageId;
                let forwardSignature;
                let forwardSenderName;
                let forwardDate;
                if (message.fwdFrom) {
                    forwardDate = new Date(message.fwdFrom.date * 1000);
                    if (message.fwdFrom.fromId) {
                        let afromId = (0, Utilities_js_1.getId)(message.fwdFrom.fromId);
                        let bfromId = (0, Utilities_js_1.getPeerId)(message.fwdFrom.fromId);
                        if (bfromId !== undefined && bfromId > 0) {
                            forwardFrom = Advanceds.User.parse(client, users.find((user) => user.id === afromId));
                        }
                        else {
                            forwardFromChat = Advanceds.Chat.parseDialog(client, message.fwdFrom.fromId, users, chats);
                            forwardFromMessageId = message.fwdFrom.channelPost;
                            forwardSignature = message.fwdFrom.postAuthor;
                        }
                    }
                    else if (message.fwdFrom.fromName) {
                        forwardSenderName = message.fwdFrom.fromName;
                    }
                }
                let animation;
                let audio;
                let document;
                let photo;
                let sticker;
                let video;
                let videoNote;
                let voice;
                let hasSpoilerMode;
                let contact;
                let dice;
                let game;
                let poll;
                let venue;
                let location;
                let webpage;
                let linkPreviewOptions;
                if (message.media && !(message.media instanceof platform_node_js_1.Raw.MessageMediaEmpty)) {
                    if (message.media instanceof platform_node_js_1.Raw.MessageMediaPhoto) {
                        hasSpoilerMode = message.media.spoiler ?? false;
                        if (message.media.photo instanceof platform_node_js_1.Raw.Photo) {
                            photo = Medias.Photo.parse(client, message.media.photo);
                        }
                    }
                    if (message.media instanceof platform_node_js_1.Raw.MessageMediaGeo) {
                        location = Medias.Location.parse(client, message.media.geo);
                    }
                    if (message.media instanceof platform_node_js_1.Raw.MessageMediaContact) {
                        contact = Medias.Contact.parse(client, message.media);
                    }
                    if (message.media instanceof platform_node_js_1.Raw.MessageMediaVenue) {
                        venue = Medias.Venue.parse(client, message.media);
                    }
                    if (message.media instanceof platform_node_js_1.Raw.MessageMediaGame) {
                        if (message.media.game instanceof platform_node_js_1.Raw.Game) {
                            game = Medias.Game.parse(client, message.media.game);
                        }
                    }
                    if (message.media instanceof platform_node_js_1.Raw.MessageMediaPoll) {
                        poll = Medias.Poll.parse(client, message.media);
                    }
                    if (message.media instanceof platform_node_js_1.Raw.MessageMediaDice) {
                        dice = Medias.Dice.parse(client, message.media);
                    }
                    if (message.media instanceof platform_node_js_1.Raw.MessageMediaWebPage) {
                        if (message.media.webpage instanceof platform_node_js_1.Raw.WebPage) {
                            webpage = Medias.WebPage.parse(client, message.media.webpage);
                        }
                        linkPreviewOptions = Medias.LinkPreviewOptions.parse(client, message.media);
                        if (message.invertMedia !== undefined) {
                            linkPreviewOptions.showAboveText = message.invertMedia;
                        }
                    }
                    if (message.media instanceof platform_node_js_1.Raw.MessageMediaDocument) {
                        hasSpoilerMode = message.media.spoiler ?? false;
                        let doc = message.media.document;
                        if (doc.attributes.some((attribute) => attribute instanceof platform_node_js_1.Raw.DocumentAttributeAudio)) {
                            let attr = doc.attributes.find((attribute) => attribute instanceof platform_node_js_1.Raw.DocumentAttributeAudio);
                            if (attr?.voice) {
                                voice = Medias.Voice.parse(client, doc);
                            }
                            else {
                                audio = Medias.Audio.parse(client, doc);
                            }
                        }
                        else if (doc.attributes.some((attribute) => attribute instanceof platform_node_js_1.Raw.DocumentAttributeAnimated)) {
                            animation = Medias.Animation.parse(client, doc);
                        }
                        else if (doc.attributes.some((attribute) => attribute instanceof platform_node_js_1.Raw.DocumentAttributeVideo)) {
                            let attr = doc.attributes.find((attribute) => attribute instanceof platform_node_js_1.Raw.DocumentAttributeVideo);
                            if (attr?.roundMessage) {
                                videoNote = Medias.VideoNote.parse(client, doc);
                            }
                            else {
                                video = Medias.Video.parse(client, doc);
                            }
                        }
                        else if (doc.attributes.some((attribute) => attribute instanceof platform_node_js_1.Raw.DocumentAttributeSticker)) {
                            sticker = Medias.Sticker.parse(client, doc);
                        }
                        else {
                            document = Medias.Document.parse(client, doc);
                        }
                    }
                }
                let from = Advanceds.User.parse(client, users.find((user) => user.id === userId));
                let senderChat = from
                    ? undefined
                    : Advanceds.Chat.parseMessage(client, message, users, chats, false);
                let chat = Advanceds.Chat.parseMessage(client, message, users, chats, true);
                let parsedMessage = new Message({
                    from,
                    senderChat,
                    chat,
                    forwardFrom,
                    forwardFromChat,
                    forwardFromMessageId,
                    forwardSignature,
                    forwardSenderName,
                    forwardDate,
                    animation,
                    audio,
                    document,
                    photo,
                    sticker,
                    video,
                    videoNote,
                    voice,
                    hasSpoilerMode,
                    contact,
                    dice,
                    game,
                    poll,
                    venue,
                    location,
                    webpage,
                    linkPreviewOptions,
                    id: message.id,
                    text: !message.media || (message.media && message.media instanceof platform_node_js_1.Raw.MessageMediaWebPage)
                        ? message.message
                        : undefined,
                    caption: message.media && !(message.media instanceof platform_node_js_1.Raw.MessageMediaWebPage)
                        ? message.message
                        : undefined,
                    captionEntities: message.media ? entities : undefined,
                    entities: !message.media ? entities : undefined,
                    outgoing: message.out,
                    date: new Date(message.date * 1000),
                    hasProtectedContent: message.noforwards,
                    mentioned: message.mentioned,
                    mediaGroupId: message.groupedId,
                    authorSignatrure: message.postAuthor,
                }, client);
                if (message.replyTo) {
                    if (message.replyTo instanceof platform_node_js_1.Raw.MessageReplyHeader) {
                        parsedMessage.isTopicMessage =
                            message.replyTo?.forumTopic ?? false;
                        parsedMessage.replyToMessageId = message.replyTo?.replyToMsgId;
                        parsedMessage.replyToTopMessageId = message.replyTo?.replyToTopId;
                        if (replies > 0) {
                            let cchat = client._cacheMessage.get(parsedMessage.chat?.id);
                            if (cchat) {
                                let cmsg = cchat.get(parsedMessage?.replyToMessageId);
                                if (cmsg) {
                                    parsedMessage.replyToMessage = cmsg;
                                }
                                else {
                                    try {
                                        let fmsg = await client.api.getMessages(parsedMessage.chat?.id, [], [message.id], replies - 1);
                                        parsedMessage.replyToMessage = fmsg[0];
                                    }
                                    catch (error) { }
                                }
                            }
                            else {
                                try {
                                    let fmsg = await client.api.getMessages(parsedMessage.chat?.id, [], [message.id], replies - 1);
                                    parsedMessage.replyToMessage = fmsg[0];
                                }
                                catch (error) { }
                            }
                        }
                    }
                    if (message.replyTo instanceof platform_node_js_1.Raw.MessageReplyStoryHeader) {
                        parsedMessage.replyToStoryId = message.replyTo.storyId;
                        parsedMessage.repliedStoryFrom = Advanceds.Chat.parseDialog(client, message.replyTo.peer, users, chats);
                    }
                }
                if (message.replyMarkup) {
                    parsedMessage.replyMarkup = await ReplyMarkup.convertReplyMarkup(message.replyMarkup, client);
                }
                if (!parsedMessage.poll) {
                    let cchat = client._cacheMessage.get(parsedMessage.chat?.id);
                    if (cchat) {
                        cchat.set(parsedMessage.id, parsedMessage);
                    }
                    else {
                        let cmsg = new Map();
                        cmsg.set(parsedMessage.id, parsedMessage);
                        client._cacheMessage.set(parsedMessage.chat?.id, cmsg);
                    }
                }
                if (message.ttlPeriod) {
                    parsedMessage.ttl = message.ttlPeriod;
                }
                return parsedMessage;
            }
        }
        return new Message({
            empty: true,
            id: message.id,
        }, client);
    }
    reply(text, more) {
        if (this.chat) {
            return this.api.sendMessage(this.chat.id, text, Object.assign({
                replyToMessageId: this.id,
            }, more));
        }
    }
    respond(text, more) {
        if (this.chat) {
            return this.api.sendMessage(this.chat.id, text, more);
        }
    }
    replyWithDoc(file, more) {
        if (this.chat) {
            return this.api.sendDocument(this.chat.id, file, more);
        }
        throw new Error('Chat not found');
    }
    rwd(file, more) {
        if (this.chat) {
            return this.api.sendDocument(this.chat.id, file, more);
        }
        throw new Error('Chat not found');
    }
    replyWithVideo(file, more) {
        if (this.chat) {
            return this.api.sendVideo(this.chat.id, file, more);
        }
        throw new Error('Chat not found');
    }
    rwv(file, more) {
        if (this.chat) {
            return this.api.sendVideo(this.chat.id, file, more);
        }
        throw new Error('Chat not found');
    }
    replyWithVideoNote(file, more) {
        if (this.chat) {
            return this.api.sendVideoNote(this.chat.id, file, more);
        }
        throw new Error('Chat not found');
    }
    rwvn(file, more) {
        if (this.chat) {
            return this.api.sendVideoNote(this.chat.id, file, more);
        }
        throw new Error('Chat not found');
    }
    replyWithAnimation(file, more) {
        if (this.chat) {
            return this.api.sendAnimation(this.chat.id, file, more);
        }
        throw new Error('Chat not found');
    }
    rwa(file, more) {
        if (this.chat) {
            return this.api.sendAnimation(this.chat.id, file, more);
        }
        throw new Error('Chat not found');
    }
    replyWithSticker(sticker, more) {
        if (this.chat) {
            return this.api.sendSticker(this.chat.id, sticker, more);
        }
        throw new Error('Chat not found');
    }
    rws(sticker, more) {
        if (this.chat) {
            return this.api.sendSticker(this.chat.id, sticker, more);
        }
        throw new Error('Chat not found');
    }
    async click({ row, col, text, filter, callbackData, password, }) {
        Logger_js_1.Logger.debug('message.click called');
        if (!this.replyMarkup) {
            throw new Error("Couldn't find any replyMarkup");
        }
        const _filter = async (cb) => {
            if (this.replyMarkup) {
                if ('inlineKeyboard' in this.replyMarkup) {
                    let _markup = this.replyMarkup;
                    for (let _rowIndex = 0; _rowIndex < _markup.inlineKeyboard.length; _rowIndex++) {
                        let _row = _markup.inlineKeyboard[_rowIndex];
                        for (let _colIndex = 0; _colIndex < _row.length; _colIndex++) {
                            if (await cb(_row[_colIndex], _rowIndex, _colIndex)) {
                                row = _rowIndex;
                                col = _colIndex;
                                return true;
                            }
                        }
                    }
                }
                if ('keyboard' in this.replyMarkup) {
                    let _markup = this.replyMarkup;
                    for (let _rowIndex = 0; _rowIndex < _markup.keyboard.length; _rowIndex++) {
                        let _row = _markup.keyboard[_rowIndex];
                        for (let _colIndex = 0; _colIndex < _row.length; _colIndex++) {
                            if (await cb(_row[_colIndex], _rowIndex, _colIndex)) {
                                row = _rowIndex;
                                col = _colIndex;
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        };
        if (text) {
            let isTrue = await _filter(async (btn, row, col) => {
                let _text = typeof btn === 'string' ? btn : btn.text;
                if (typeof text === 'string') {
                    return text === _text;
                }
                if (typeof text === 'function') {
                    return text(_text, row, col);
                }
                return false;
            });
            if (!isTrue)
                return;
        }
        if (filter) {
            let isTrue = await _filter(filter);
            if (!isTrue)
                return;
        }
        if (callbackData) {
            let isTrue = await _filter(async (btn, _row, _col) => {
                let _cb = typeof btn !== 'string' && 'callbackData' in btn ? btn.callbackData : '';
                return callbackData === _cb;
            });
            if (!isTrue)
                return;
        }
        if (row !== undefined || col !== undefined) {
            if (this.replyMarkup) {
                if ('inlineKeyboard' in this.replyMarkup) {
                    let _markup = this.replyMarkup;
                    let keyboard = _markup.inlineKeyboard[row ?? 0][col ?? 0];
                    if (keyboard && 'callbackData' in keyboard) {
                        let encryptedPassword;
                        if (password !== undefined) {
                            let pwd = await this.api.invoke(new platform_node_js_1.Raw.account.GetPassword());
                            encryptedPassword = await platform_node_js_1.Cryptos.Password.computePasswordCheck(pwd, password);
                        }
                        let request = new platform_node_js_1.Raw.messages.GetBotCallbackAnswer({
                            peer: this.chat
                                ? await this.core.resolvePeer(this.chat.id)
                                : new platform_node_js_1.Raw.InputPeerEmpty(),
                            msgId: this.id,
                            data: platform_node_js_1.Buffer.from(keyboard.callbackData),
                            password: encryptedPassword,
                        });
                        return await this.api.invoke(request);
                    }
                    if (keyboard && 'callbackGame' in keyboard) {
                        let request = new platform_node_js_1.Raw.messages.GetBotCallbackAnswer({
                            peer: this.chat
                                ? await this.core.resolvePeer(this.chat.id)
                                : new platform_node_js_1.Raw.InputPeerEmpty(),
                            msgId: this.id,
                            game: true,
                        });
                        return await this.api.invoke(request);
                    }
                    if (keyboard && 'switchInlineQuery' in keyboard) {
                        let request = new platform_node_js_1.Raw.messages.StartBot({
                            bot: this.from ? await this.core.resolvePeer(this.from.id) : new platform_node_js_1.Raw.InputPeerEmpty(),
                            peer: this.chat
                                ? await this.core.resolvePeer(this.chat.id)
                                : new platform_node_js_1.Raw.InputPeerEmpty(),
                            startParam: keyboard.switchInlineQuery ?? '',
                            randomId: this.client._rndMsgId.getMsgId(),
                        });
                        return await this.api.invoke(request);
                    }
                    if (keyboard && 'switchInlineQueryCurrentChat' in keyboard) {
                        let request = new platform_node_js_1.Raw.messages.StartBot({
                            bot: this.from ? await this.core.resolvePeer(this.from.id) : new platform_node_js_1.Raw.InputPeerEmpty(),
                            peer: this.chat
                                ? await this.core.resolvePeer(this.chat.id)
                                : new platform_node_js_1.Raw.InputPeerEmpty(),
                            startParam: keyboard.switchInlineQueryCurrentChat ?? '',
                            randomId: this.client._rndMsgId.getMsgId(),
                        });
                        return await this.api.invoke(request);
                    }
                }
            }
        }
        return;
    }
}
exports.Message = Message;
