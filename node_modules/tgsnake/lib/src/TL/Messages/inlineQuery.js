"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChosenInlineResult = exports.InlineQuery = void 0;
const TL_js_1 = require("../TL.js");
const platform_node_js_1 = require("../../platform.node.js");
const User_js_1 = require("../Advanced/User.js");
const Venue_js_1 = require("./Medias/Venue.js");
const Utilities_js_1 = require("../../Utilities.js");
class InlineQuery extends TL_js_1.TLObject {
    id;
    query;
    offset;
    from;
    chatType;
    location;
    constructor({ id, from, query, offset, chatType, location }, client) {
        super(client);
        this.id = id;
        this.from = from;
        this.query = query;
        this.offset = offset;
        this.chatType = chatType;
        this.location = location;
    }
    static parse(client, update, users) {
        return new InlineQuery({
            id: String(update.queryId),
            query: update.query,
            offset: update.offset,
            location: update.geo ? Venue_js_1.Location.parse(client, update.geo) : undefined,
            chatType: update.peerType instanceof platform_node_js_1.Raw.InlineQueryPeerTypeSameBotPM ||
                update.peerType instanceof platform_node_js_1.Raw.InlineQueryPeerTypeBotPM
                ? 'sender'
                : update.peerType instanceof platform_node_js_1.Raw.InlineQueryPeerTypePM
                    ? 'private'
                    : update.peerType instanceof platform_node_js_1.Raw.InlineQueryPeerTypeChat
                        ? 'group'
                        : update.peerType instanceof platform_node_js_1.Raw.InlineQueryPeerTypeMegagroup
                            ? 'supergroup'
                            : update.peerType instanceof platform_node_js_1.Raw.InlineQueryPeerTypeBroadcast
                                ? 'channel'
                                : undefined,
            from: User_js_1.User.parse(client, users.find((user) => user.id === update.userId)),
        }, client);
    }
}
exports.InlineQuery = InlineQuery;
class ChosenInlineResult extends TL_js_1.TLObject {
    resultId;
    query;
    from;
    location;
    inlineMessageId;
    constructor({ resultId, query, from, location, inlineMessageId }, client) {
        super(client);
        this.resultId = resultId;
        this.query = query;
        this.from = from;
        this.location = location;
        this.inlineMessageId = inlineMessageId;
    }
    static parse(client, update, users) {
        return new ChosenInlineResult({
            resultId: update.id,
            query: update.query,
            location: update.geo ? Venue_js_1.Location.parse(client, update.geo) : undefined,
            inlineMessageId: update.msgId ? (0, Utilities_js_1.createInlineMsgId)(update.msgId) : undefined,
            from: User_js_1.User.parse(client, users.find((user) => user.id === update.userId)),
        }, client);
    }
}
exports.ChosenInlineResult = ChosenInlineResult;
