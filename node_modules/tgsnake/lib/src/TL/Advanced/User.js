"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.User = void 0;
const TL_js_1 = require("../TL.js");
const platform_node_js_1 = require("../../platform.node.js");
const Restriction_js_1 = require("./Restriction.js");
const ChatPhoto_js_1 = require("./ChatPhoto.js");
class User extends TL_js_1.TLObject {
    id;
    accessHash;
    isSelf;
    isContact;
    isMutualContact;
    isDeleted;
    isBot;
    isVerified;
    isRestricted;
    isScam;
    isFake;
    isSupport;
    isPremium;
    firstname;
    lastname;
    status;
    lastOnlineDate;
    nextOfflineDate;
    username;
    languageCode;
    dcId;
    phoneNumber;
    photo;
    restrictions;
    addedToAttachmentMenu;
    canJoinGroups;
    canReadAllGroupMessages;
    supportsInlineQueries;
    constructor({ id, accessHash, isSelf, isContact, isMutualContact, isDeleted, isBot, isVerified, isRestricted, isScam, isFake, isSupport, isPremium, firstname, lastname, status, lastOnlineDate, nextOfflineDate, username, languageCode, dcId, phoneNumber, photo, restrictions, addedToAttachmentMenu, canJoinGroups, canReadAllGroupMessages, supportsInlineQueries, }, client) {
        super(client);
        this.id = id;
        this.accessHash = accessHash;
        this.isSelf = isSelf;
        this.isContact = isContact;
        this.isMutualContact = isMutualContact;
        this.isDeleted = isDeleted;
        this.isBot = isBot;
        this.isVerified = isVerified;
        this.isRestricted = isRestricted;
        this.isScam = isScam;
        this.isFake = isFake;
        this.isSupport = isSupport;
        this.isPremium = isPremium;
        this.firstname = firstname;
        this.lastname = lastname;
        this.status = status;
        this.lastOnlineDate = lastOnlineDate;
        this.nextOfflineDate = nextOfflineDate;
        this.username = username;
        this.languageCode = languageCode;
        this.dcId = dcId;
        this.phoneNumber = phoneNumber;
        this.photo = photo;
        this.restrictions = restrictions;
        this.addedToAttachmentMenu = addedToAttachmentMenu;
        this.canJoinGroups = canJoinGroups;
        this.canReadAllGroupMessages = canReadAllGroupMessages;
        this.supportsInlineQueries = supportsInlineQueries;
    }
    static parse(client, user) {
        if (user) {
            if (user instanceof platform_node_js_1.Raw.User) {
                user;
                return new User({
                    id: user.id,
                    accessHash: user.accessHash,
                    isSelf: user.self,
                    isContact: user.contact,
                    isMutualContact: user.mutualContact,
                    isDeleted: user.deleted,
                    isBot: user.bot,
                    isVerified: user.verified,
                    isRestricted: user.restricted,
                    isScam: user.scam,
                    isFake: user.fake,
                    isSupport: user.support,
                    isPremium: user.premium,
                    firstname: user.firstName,
                    lastname: user.lastName,
                    ...User.parseStatus(user.status, user.bot),
                    username: user.username,
                    languageCode: user.langCode,
                    dcId: user.photo && user.photo.dcId ? user.photo.dcId : undefined,
                    phoneNumber: user.phone,
                    photo: ChatPhoto_js_1.ChatPhoto.parse(client, user.photo, user.id, user.accessHash),
                    restrictions: User.parseRestrictions(user.restrictionReason ? user.restrictionReason : [], client),
                    addedToAttachmentMenu: Boolean(user.botAttachMenu && user.attachMenuEnabled),
                    canJoinGroups: !user.botNochats,
                    canReadAllGroupMessages: user.botChatHistory,
                    supportsInlineQueries: Boolean(user.botInlineGeo && user.botInlinePlaceholder),
                }, client);
            }
            return new User({ id: user.id }, client);
        }
        return;
    }
    static parseRestrictions(restrictions, client) {
        let results = [];
        for (let restriction of restrictions) {
            results.push(Restriction_js_1.Restriction.parse(client, restriction));
        }
        return results;
    }
    static parseStatus(userStatus, isBot = false) {
        if (!userStatus || isBot || userStatus instanceof platform_node_js_1.Raw.UserStatusEmpty) {
            return {
                status: undefined,
                lastOnlineDate: undefined,
                nextOfflineDate: undefined,
            };
        }
        if (userStatus instanceof platform_node_js_1.Raw.UserStatusOnline) {
            userStatus;
            return {
                status: 'online',
                lastOnlineDate: undefined,
                nextOfflineDate: new Date(userStatus.expires * 1000),
            };
        }
        if (userStatus instanceof platform_node_js_1.Raw.UserStatusOffline) {
            userStatus;
            return {
                status: 'offline',
                lastOnlineDate: new Date(userStatus.wasOnline * 1000),
                nextOfflineDate: undefined,
            };
        }
        if (userStatus instanceof platform_node_js_1.Raw.UserStatusRecently) {
            userStatus;
            return {
                status: 'recently',
                lastOnlineDate: undefined,
                nextOfflineDate: undefined,
            };
        }
        if (userStatus instanceof platform_node_js_1.Raw.UserStatusLastWeek) {
            userStatus;
            return {
                status: 'withinWeek',
                lastOnlineDate: undefined,
                nextOfflineDate: undefined,
            };
        }
        if (userStatus instanceof platform_node_js_1.Raw.UserStatusLastMonth) {
            userStatus;
            return {
                status: 'withinMonth',
                lastOnlineDate: undefined,
                nextOfflineDate: undefined,
            };
        }
        return {
            status: 'longTimeAgo',
            lastOnlineDate: undefined,
            nextOfflineDate: undefined,
        };
    }
    static parseUpdateStatus(client, userStatus) {
        return new User({
            id: userStatus.userId,
            ...User.parseStatus(userStatus.status),
        }, client);
    }
    mention({ name, style } = {}) {
        let _name = name ?? this.firstname;
        let _style = style ?? 'html';
        if (_style.toLowerCase() === 'md' || _style.toLowerCase() === 'markdown') {
            return `[${_name}](tg://user?id=${this.id})`;
        }
        return `<a href="tg://user?id=${this.id}">${_name}</a>`;
    }
    get inputPeer() {
        if (this.isSelf) {
            return new platform_node_js_1.Raw.InputPeerSelf();
        }
        return new platform_node_js_1.Raw.InputPeerUser({
            userId: this.id,
            accessHash: this.accessHash ?? BigInt(0),
        });
    }
}
exports.User = User;
