"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chat = void 0;
const TL_js_1 = require("../TL.js");
const platform_node_js_1 = require("../../platform.node.js");
const ChatPermission_js_1 = require("./ChatPermission.js");
const Restriction_js_1 = require("./Restriction.js");
const ChatPhoto_js_1 = require("./ChatPhoto.js");
const Utilities_js_1 = require("../../Utilities.js");
class Chat extends TL_js_1.TLObject {
    id;
    accessHash;
    type;
    title;
    username;
    firstname;
    lastname;
    photo;
    bio;
    hasPrivateForwards;
    joinToSendMessages;
    joinByRequest;
    description;
    inviteLink;
    pinnedMessage;
    permissions;
    slowModeDelay;
    messageAutoDeleteTime;
    hasProtectContent;
    stickerSetName;
    canSetStickerSet;
    linkedChatId;
    location;
    isVerified;
    isRestricted;
    isCreator;
    isScam;
    isFake;
    isSupport;
    dcId;
    membersCount;
    restrictions;
    sendAsChat;
    availableReactions;
    isLeft;
    isInactive;
    constructor({ id, accessHash, type, title, username, firstname, lastname, photo, bio, hasPrivateForwards, joinToSendMessages, joinByRequest, description, inviteLink, pinnedMessage, permissions, slowModeDelay, messageAutoDeleteTime, hasProtectContent, stickerSetName, canSetStickerSet, linkedChatId, location, isVerified, isRestricted, isCreator, isScam, isFake, isSupport, dcId, membersCount, restrictions, sendAsChat, availableReactions, isLeft, isInactive, }, client) {
        super(client);
        this.id = id;
        this.accessHash = accessHash;
        this.type = type;
        this.title = title;
        this.username = username;
        this.firstname = firstname;
        this.lastname = lastname;
        this.photo = photo;
        this.bio = bio;
        this.hasPrivateForwards = hasPrivateForwards;
        this.joinToSendMessages = joinToSendMessages;
        this.joinByRequest = joinByRequest;
        this.description = description;
        this.inviteLink = inviteLink;
        this.pinnedMessage = pinnedMessage;
        this.permissions = permissions;
        this.slowModeDelay = slowModeDelay;
        this.messageAutoDeleteTime = messageAutoDeleteTime;
        this.hasProtectContent = hasProtectContent;
        this.stickerSetName = stickerSetName;
        this.canSetStickerSet = canSetStickerSet;
        this.linkedChatId = linkedChatId;
        this.location = location;
        this.isVerified = isVerified;
        this.isRestricted = isRestricted;
        this.isCreator = isCreator;
        this.isScam = isScam;
        this.isFake = isFake;
        this.isSupport = isSupport;
        this.dcId = dcId;
        this.membersCount = membersCount;
        this.restrictions = restrictions;
        this.sendAsChat = sendAsChat;
        this.availableReactions = availableReactions;
        this.isLeft = isLeft;
        this.isInactive = isInactive;
    }
    static parseMessage(client, message, users, chats, chat) {
        let peerId = (0, Utilities_js_1.getId)(message.peerId);
        let fromId = (0, Utilities_js_1.getId)(message.fromId);
        let chatId = chat ? peerId || fromId : fromId || peerId;
        let merge = [...users, ...chats];
        if (!chatId)
            return;
        let filtered = merge.filter((c) => c.id === chatId)[0];
        if (filtered) {
            if (filtered instanceof platform_node_js_1.Raw.User || filtered instanceof platform_node_js_1.Raw.UserEmpty) {
                return Chat.parseUser(client, filtered);
            }
            if (filtered instanceof platform_node_js_1.Raw.Chat ||
                filtered instanceof platform_node_js_1.Raw.ChatEmpty ||
                filtered instanceof platform_node_js_1.Raw.ChatForbidden) {
                return Chat.parseChat(client, filtered);
            }
            return Chat.parseChannel(client, filtered);
        }
        return;
    }
    static parseChat(client, chat) {
        if (chat) {
            if (chat instanceof platform_node_js_1.Raw.ChatEmpty) {
                return new Chat({
                    id: BigInt(-chat.id),
                    type: 'group',
                }, client);
            }
            if (chat instanceof platform_node_js_1.Raw.ChatForbidden) {
                return new Chat({
                    id: BigInt(-chat.id),
                    title: chat.title,
                    type: 'group',
                }, client);
            }
            return new Chat({
                id: BigInt(-chat.id),
                type: 'group',
                title: chat.title,
                photo: ChatPhoto_js_1.ChatPhoto.parse(client, chat.photo, -chat.id, BigInt(0)),
                permissions: ChatPermission_js_1.ChatPermission.parse(client, chat.defaultBannedRights),
                hasProtectContent: chat.noforwards,
                isCreator: chat.creator,
                dcId: chat.photo && chat.photo.dcId ? chat.photo.dcId : undefined,
                membersCount: chat.participantsCount,
                isInactive: chat.deactivated,
                isLeft: chat.left,
            }, client);
        }
    }
    static parseChannel(client, channel) {
        if (channel) {
            if (channel instanceof platform_node_js_1.Raw.ChannelForbidden) {
                return new Chat({
                    id: platform_node_js_1.Helpers.getChannelId(channel.id),
                    accessHash: channel.accessHash,
                    type: channel.broadcast ? 'channel' : 'supergroup',
                    title: channel.title,
                }, client);
            }
            return new Chat({
                id: platform_node_js_1.Helpers.getChannelId(channel.id),
                accessHash: channel.accessHash,
                type: channel.broadcast ? 'channel' : 'supergroup',
                title: channel.title,
                username: channel.username,
                photo: ChatPhoto_js_1.ChatPhoto.parse(client, channel.photo, platform_node_js_1.Helpers.getChannelId(channel.id), channel.accessHash),
                hasPrivateForwards: channel.noforwards,
                joinToSendMessages: channel.joinToSend,
                joinByRequest: channel.joinRequest,
                permissions: ChatPermission_js_1.ChatPermission.parse(client, channel.defaultBannedRights),
                hasProtectContent: channel.noforwards,
                isVerified: channel.verified,
                isRestricted: channel.restricted,
                isCreator: channel.creator,
                isScam: channel.scam,
                isFake: channel.fake,
                dcId: channel.photo && channel.photo.dcId ? channel.photo.dcId : undefined,
                membersCount: channel.participantsCount,
                restrictions: Chat.parseRestrictions(client, channel.restrictionReason ? channel.restrictionReason : []),
                isLeft: channel.left,
            }, client);
        }
    }
    static parseUser(client, user) {
        if (user) {
            if (user instanceof platform_node_js_1.Raw.UserEmpty) {
                return new Chat({
                    id: user.id,
                    type: 'private',
                }, client);
            }
            return new Chat({
                id: user.id,
                accessHash: user.accessHash,
                type: 'private',
                username: user.username,
                firstname: user.firstName,
                lastname: user.lastName,
                photo: ChatPhoto_js_1.ChatPhoto.parse(client, user.photo, user.id, user.accessHash ?? BigInt(0)),
                isVerified: user.verified,
                isRestricted: user.restricted,
                isSupport: user.support,
                dcId: user.photo ? user.photo.dcId : undefined,
                restrictions: Chat.parseRestrictions(client, user.restrictionReason ? user.restrictionReason : []),
            }, client);
        }
    }
    static parseDialog(client, peer, users, chats) {
        let peerId = (0, Utilities_js_1.getId)(peer);
        let merge = [...users, ...chats];
        if (!peerId)
            return;
        let filtered = merge.filter((c) => c.id === peerId)[0];
        if (filtered) {
            if (filtered instanceof platform_node_js_1.Raw.User || filtered instanceof platform_node_js_1.Raw.UserEmpty) {
                return Chat.parseUser(client, filtered);
            }
            if (filtered instanceof platform_node_js_1.Raw.Chat ||
                filtered instanceof platform_node_js_1.Raw.ChatEmpty ||
                filtered instanceof platform_node_js_1.Raw.ChatForbidden) {
                return Chat.parseChat(client, filtered);
            }
            return Chat.parseChannel(client, filtered);
        }
    }
    static parseRestrictions(client, restrictions) {
        let results = [];
        for (let restriction of restrictions) {
            results.push(Restriction_js_1.Restriction.parse(client, restriction));
        }
        return results.length ? results : undefined;
    }
    get inputPeer() {
        if (this.type === 'private') {
            return new platform_node_js_1.Raw.InputPeerUser({
                userId: this.id,
                accessHash: this.accessHash ?? BigInt(0),
            });
        }
        else if (this.type === 'group') {
            return new platform_node_js_1.Raw.InputPeerChat({
                chatId: -this.id,
            });
        }
        else {
            return new platform_node_js_1.Raw.InputPeerChannel({
                channelId: platform_node_js_1.Helpers.getChannelId(this.id),
                accessHash: this.accessHash ?? BigInt(0),
            });
        }
    }
}
exports.Chat = Chat;
