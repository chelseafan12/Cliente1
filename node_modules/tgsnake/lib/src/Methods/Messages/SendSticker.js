"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendSticker = void 0;
const SendMedia_js_1 = require("./SendMedia.js");
const platform_node_js_1 = require("../../platform.node.js");
const Utilities_js_1 = require("../../Utilities.js");
const Logger_js_1 = require("../../Context/Logger.js");
async function sendSticker(client, chatId, file, more = {}) {
    Logger_js_1.Logger.debug(`exec: send_sticker chat ${typeof chatId} (${chatId}) ${(0, Utilities_js_1.parseArgObjAsStr)({
        file,
    })} ${(0, Utilities_js_1.parseArgObjAsStr)(more)}`);
    var { disableNotification, replyToMessageId, replyToStoryId, messageThreadId, scheduleDate, sendAsChannel, protectContent, filename, progress, mimetype, hasSpoiler, } = more;
    if (typeof file === 'string') {
        file;
        if (/^http/i.test(file)) {
            var savedFile = new platform_node_js_1.Raw.InputMediaDocumentExternal({
                spoiler: hasSpoiler,
                url: file,
            });
        }
        else if (/^(\/|\.\.?\/|~\/)/i.test(file)) {
            var savedFile = new platform_node_js_1.Raw.InputMediaUploadedDocument({
                file: (await client.core.saveFileStream({
                    source: platform_node_js_1.fs.createReadStream(file),
                    fileName: filename ?? platform_node_js_1.path.basename(file),
                    progress: progress,
                })),
                mimeType: mimetype ?? (0, Utilities_js_1.findMimeType)(filename ?? platform_node_js_1.path.basename(file) ?? '') ?? 'image/webp',
                forceFile: false,
                spoiler: hasSpoiler,
                attributes: [
                    new platform_node_js_1.Raw.DocumentAttributeFilename({
                        fileName: filename ?? platform_node_js_1.path.basename(file) ?? `tg-${Date.now()}`,
                    }),
                ],
            });
        }
        else {
            const media = platform_node_js_1.FileId.decodeFileId(file);
            if (media.fileType === platform_node_js_1.FileType.STICKER) {
                var savedFile = new platform_node_js_1.Raw.InputMediaDocument({
                    spoiler: hasSpoiler,
                    id: new platform_node_js_1.Raw.InputDocument({
                        id: media.id,
                        accessHash: media.accessHash,
                        fileReference: media.fileReference,
                    }),
                });
            }
            else {
                throw new Error('invalid file id');
            }
        }
    }
    else if (platform_node_js_1.Buffer.isBuffer(file)) {
        file;
        var savedFile = new platform_node_js_1.Raw.InputMediaUploadedDocument({
            file: (await client.core.saveFile({
                source: file,
                fileName: filename,
                progress: progress,
            })),
            mimeType: mimetype ?? (0, Utilities_js_1.findMimeType)(filename ?? '') ?? 'image/webp',
            forceFile: false,
            spoiler: hasSpoiler,
            attributes: [
                new platform_node_js_1.Raw.DocumentAttributeFilename({
                    fileName: filename ?? `tg-${Date.now()}`,
                }),
            ],
        });
    }
    else if ('pipe' in file) {
        var savedFile = new platform_node_js_1.Raw.InputMediaUploadedDocument({
            file: (await client.core.saveFileStream({
                source: file,
                fileName: filename,
                progress: progress,
            })),
            mimeType: mimetype ?? (0, Utilities_js_1.findMimeType)(filename ?? '') ?? 'image/webp',
            forceFile: false,
            spoiler: hasSpoiler,
            attributes: [
                new platform_node_js_1.Raw.DocumentAttributeFilename({
                    fileName: filename ?? `tg-${Date.now()}`,
                }),
            ],
        });
    }
    else {
        throw new Error('unknown file');
    }
    return (0, SendMedia_js_1.sendMedia)(client, chatId, savedFile, {
        disableNotification,
        replyToMessageId,
        replyToStoryId,
        messageThreadId,
        scheduleDate,
        sendAsChannel,
        protectContent,
    });
}
exports.sendSticker = sendSticker;
