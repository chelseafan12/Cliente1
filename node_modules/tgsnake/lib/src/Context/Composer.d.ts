import { Raw } from '../platform.node.js';
import { FilterContext } from './Filters.js';
import { TypeUpdate, ContextUpdate } from '../TL/Updates/index.js';
export type MaybeArray<T> = T | T[];
export type MaybePromise<T> = T | Promise<T>;
export type NextFn = () => MaybePromise<void>;
export type MiddlewareFn<C> = (ctx: C, next: NextFn) => MaybePromise<any>;
export interface MiddlewareObj<C> {
    middleware: () => MiddlewareFn<C>;
}
export type ErrorHandler<T> = (error: Error, context: Combine<Combine<Combine<TypeUpdate, ContextUpdate>, Raw.TypeUpdate>, T>) => MaybePromise<any>;
export type Middleware<C> = MiddlewareFn<C> | MiddlewareObj<C>;
export type Combine<T, U> = T & Partial<U>;
export declare function concat<C>(first: MiddlewareFn<C>, andThen: MiddlewareFn<C>): (ctx: C, next: NextFn) => Promise<void>;
export declare function pass<C>(_ctx: C, next: NextFn): MaybePromise<void>;
export declare const leaf: () => Promise<void>;
export declare function triggerFn(trigger: MaybeArray<string | RegExp>): Array<(content: string) => RegExpExecArray | string | null>;
export declare function match(content: string, triggers: Array<(content: string) => RegExpExecArray | string | null>): boolean;
export declare function toArray<T>(e: MaybeArray<T>): Array<T>;
export declare function run<C>(middleware: MiddlewareFn<C>, ctx: C): Promise<void>;
export declare class Composer<T = {}> implements MiddlewareObj<Combine<Combine<Combine<TypeUpdate, ContextUpdate>, Raw.TypeUpdates>, T>> {
    private handler;
    context: Partial<T>;
    prefix: string;
    constructor(...middleware: Array<Middleware<Combine<Combine<Combine<TypeUpdate, ContextUpdate>, Raw.TypeUpdates>, T>>>);
    middleware(): MiddlewareFn<Combine<Combine<Combine<TypeUpdate, ContextUpdate>, Raw.TypeUpdates>, T>>;
    use(...middleware: Array<Middleware<Combine<Combine<Combine<TypeUpdate, ContextUpdate>, Raw.TypeUpdates>, T>>>): Composer<T>;
    on<K extends keyof FilterContext>(filters: MaybeArray<K>, ...middleware: Array<Middleware<Combine<Combine<FilterContext[K], ContextUpdate>, T>>>): Composer<T>;
    filter<K>(predicate: (ctx: K) => MaybePromise<boolean>, ...middleware: Array<Middleware<K>>): Composer<T>;
    drop(predicate: (ctx: Combine<Combine<Combine<TypeUpdate, ContextUpdate>, Raw.TypeUpdates>, T>) => MaybePromise<boolean>, ...middleware: Array<Middleware<Combine<Combine<Combine<TypeUpdate, ContextUpdate>, Raw.TypeUpdates>, T>>>): Composer<T>;
    fork(...middleware: Array<Middleware<Combine<Combine<Combine<TypeUpdate, ContextUpdate>, Raw.TypeUpdates>, T>>>): Composer<T>;
    lazy(middlewareFactory: (ctx: Combine<Combine<Combine<TypeUpdate, ContextUpdate>, Raw.TypeUpdates>, T>) => MaybePromise<any>): Composer<T>;
    route<R extends Record<PropertyKey, Middleware<Combine<Combine<Combine<TypeUpdate, ContextUpdate>, Raw.TypeUpdates>, T>>>>(router: (ctx: Combine<Combine<Combine<TypeUpdate, ContextUpdate>, Raw.TypeUpdates>, T>) => MaybePromise<string | undefined>, routeHandlers: R, fallback?: Middleware<Combine<Combine<Combine<TypeUpdate, ContextUpdate>, Raw.TypeUpdates>, T>>): Composer<T>;
    branch(predicate: (ctx: Combine<Combine<Combine<TypeUpdate, ContextUpdate>, Raw.TypeUpdates>, T>) => MaybePromise<boolean>, trueMiddleware: Middleware<Combine<Combine<Combine<TypeUpdate, ContextUpdate>, Raw.TypeUpdates>, T>>, falseMiddleware: Middleware<Combine<Combine<Combine<TypeUpdate, ContextUpdate>, Raw.TypeUpdates>, T>>): Composer<T>;
    toJSON(): {
        [key: string]: any;
    };
    toString(): string;
    command(trigger: MaybeArray<string | RegExp>, ...middleware: Array<Middleware<Combine<Combine<FilterContext['msg.text'], ContextUpdate>, T>>>): Composer<T>;
    cmd(trigger: MaybeArray<string | RegExp>, ...middleware: Array<Middleware<Combine<Combine<FilterContext['msg.text'], ContextUpdate>, T>>>): Composer<T>;
    hears(trigger: MaybeArray<string | RegExp>, ...middleware: Array<Middleware<Combine<Combine<FilterContext['msg.text'], ContextUpdate>, T>>>): Composer<T>;
    hear(trigger: MaybeArray<string | RegExp>, ...middleware: Array<Middleware<Combine<Combine<FilterContext['msg.text'], ContextUpdate>, T>>>): Composer<T>;
    action(trigger: MaybeArray<string | RegExp>, ...middleware: Array<Middleware<Combine<Combine<FilterContext['cb.data'], ContextUpdate>, T>>>): Composer<T>;
    inlineQuery(trigger: MaybeArray<string | RegExp>, ...middleware: Array<Middleware<Combine<Combine<FilterContext['inlineQuery.from'], ContextUpdate>, T>>>): Composer<T>;
}
