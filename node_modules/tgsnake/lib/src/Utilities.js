"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getChannelId = exports.buildReply = exports.parseArgObjAsStr = exports.uploadThumbnail = exports.findMimeType = exports.createInlineMsgId = exports.getPeerId = exports.getId = exports.parseMessages = exports.open = exports.parseDialog = void 0;
const node_child_process_1 = require("node:child_process");
const platform_node_js_1 = require("./platform.node.js");
const Message_js_1 = require("./TL/Messages/Message.js");
function parseDialog(chats, users) {
    return [
        chats.filter((chat) => {
            if (chat instanceof platform_node_js_1.Raw.Chat ||
                chat instanceof platform_node_js_1.Raw.ChatEmpty ||
                chat instanceof platform_node_js_1.Raw.ChatForbidden)
                return true;
            if (chat instanceof platform_node_js_1.Raw.Channel || chat instanceof platform_node_js_1.Raw.ChannelForbidden)
                return true;
            return false;
        }),
        users.filter((user) => {
            return user instanceof platform_node_js_1.Raw.User || user instanceof platform_node_js_1.Raw.UserEmpty;
        }),
    ];
}
exports.parseDialog = parseDialog;
function open(url) {
    if (process.platform === 'darwin') {
        return (0, node_child_process_1.exec)(`open ${url}`);
    }
    if (process.platform === 'win32') {
        return (0, node_child_process_1.exec)(`start ${url}`);
    }
    return (0, node_child_process_1.exec)(`xdg-open ${url}`);
}
exports.open = open;
async function parseMessages(client, messages, replies = 1) {
    let [chats, users] = parseDialog(messages.chats, messages.users);
    const parsedMessages = [];
    if ('messages' in messages) {
        for (let message of messages.messages) {
            parsedMessages.push(await Message_js_1.Message.parse(client, message, chats, users, 0));
        }
        if (replies) {
            let messagesWithReplies = new Map();
            for (let message of messages.messages) {
                if (!(message instanceof platform_node_js_1.Raw.MessageEmpty) &&
                    message.replyTo &&
                    message.replyTo instanceof platform_node_js_1.Raw.MessageReplyHeader &&
                    message.replyTo.replyToMsgId) {
                    messagesWithReplies.set(message.id, message.replyTo.replyToMsgId);
                }
            }
            if (messagesWithReplies.size) {
                let chatId = BigInt(0);
                for (let message of parsedMessages) {
                    if (message.chat) {
                        chatId = message.chat.id;
                        break;
                    }
                }
                let replyMsgs = await client.api.getMessages(chatId, [], [...messagesWithReplies.keys()], replies - 1);
                for (let msg of parsedMessages) {
                    let replyId = messagesWithReplies.get(msg.id);
                    for (let reply of replyMsgs) {
                        if (reply.id == replyId) {
                            msg.replyToMessage = reply;
                        }
                    }
                }
            }
        }
    }
    return parsedMessages;
}
exports.parseMessages = parseMessages;
function getId(peer) {
    if (peer instanceof platform_node_js_1.Raw.PeerUser)
        return peer.userId;
    if (peer instanceof platform_node_js_1.Raw.PeerChannel)
        return peer.channelId;
    if (peer instanceof platform_node_js_1.Raw.PeerChat)
        return peer.chatId;
    return;
}
exports.getId = getId;
function getPeerId(peer) {
    if (peer instanceof platform_node_js_1.Raw.PeerUser)
        return peer.userId;
    if (peer instanceof platform_node_js_1.Raw.PeerChat)
        return BigInt(-peer.chatId);
    if (peer instanceof platform_node_js_1.Raw.PeerChannel)
        return BigInt(platform_node_js_1.Helpers.MAX_CHANNEL_ID - peer.channelId);
    return;
}
exports.getPeerId = getPeerId;
function createInlineMsgId(msgId) {
    if (msgId instanceof platform_node_js_1.Raw.InputBotInlineMessageID) {
        const writer = new platform_node_js_1.Writer();
        writer.writeInt(msgId.dcId).writeBigInt(msgId.id).writeBigInt(msgId.accessHash);
        return (0, platform_node_js_1.base64_url_encode)(writer.results());
    }
    const writer = new platform_node_js_1.Writer();
    writer
        .writeInt(msgId.dcId)
        .writeBigInt(msgId.ownerId)
        .writeInt(msgId.id)
        .writeBigInt(msgId.accessHash);
    return (0, platform_node_js_1.base64_url_encode)(writer.results());
}
exports.createInlineMsgId = createInlineMsgId;
function findMimeType(file) {
    if (/tgs$/.test(file)) {
        return 'application/x-tgsticker';
    }
    const mime = (0, platform_node_js_1.mimetypes)(file);
    if (mime) {
        return mime;
    }
    return 'application/zip';
}
exports.findMimeType = findMimeType;
function uploadThumbnail(client, thumb) {
    if (typeof thumb !== 'string' && 'pipe' in thumb) {
        return client.core.saveFileStream({
            source: thumb,
        });
    }
    if (platform_node_js_1.Buffer.isBuffer(thumb)) {
        return client.core.saveFile({
            source: thumb,
        });
    }
    return client.core.saveFileStream({
        source: platform_node_js_1.fs.createReadStream(thumb),
    });
}
exports.uploadThumbnail = uploadThumbnail;
function parseArgObjAsStr(arg) {
    let res = '';
    for (let [key, value] of Object.entries(arg)) {
        if (typeof value === 'object') {
            if (Array.isArray(value)) {
                value = '[array]';
            }
            else if (platform_node_js_1.Buffer.isBuffer(value)) {
                value = '[buffer]';
            }
            else {
                value = '[object]';
            }
        }
        else if (typeof value !== 'undefined' && typeof value !== 'boolean') {
            value = `${typeof value}[${String(value).length}](${String(value).length >= 10 ? `${String(value).slice(0, 5)}...` : value})`;
        }
        res += `${key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`)} ${value} `;
    }
    return res.trim();
}
exports.parseArgObjAsStr = parseArgObjAsStr;
async function buildReply(client, replyParameters, messageThreadId) {
    if ('quoteParseMode' in replyParameters &&
        !('quoteEntities' in replyParameters) &&
        'quote' in replyParameters) {
        const [t, e] = await platform_node_js_1.Parser.parse(replyParameters.quote ?? '', replyParameters.quoteParseMode);
        replyParameters.quoteEntities = e;
        replyParameters.quote = t;
    }
    const peer = 'chatId' in replyParameters
        ? await client._client.resolvePeer(replyParameters.chatId)
        : undefined;
    return new platform_node_js_1.Raw.InputReplyToMessage({
        replyToMsgId: replyParameters.messageId,
        topMsgId: messageThreadId,
        replyToPeerId: peer,
        quoteText: replyParameters.quote ?? '',
        quoteEntities: replyParameters.quoteEntities
            ? await platform_node_js_1.Parser.toRaw(client._client, replyParameters.quoteEntities)
            : undefined,
        quoteOffset: replyParameters.quotePosition,
    });
}
exports.buildReply = buildReply;
function getChannelId(update) {
    if ('channelId' in update && 'pts' in update) {
        return BigInt(platform_node_js_1.Helpers.getChannelId(update.channelId));
    }
    if (update instanceof platform_node_js_1.Raw.UpdateNewChannelMessage ||
        update instanceof platform_node_js_1.Raw.UpdateEditChannelMessage) {
        return getPeerId(update.message.peerId) ?? BigInt(0);
    }
    return BigInt(0);
}
exports.getChannelId = getChannelId;
