"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TCPIntermediateO = void 0;
const tcp_js_1 = require("./tcp.js");
const helpers_js_1 = require("../../helpers.js");
const platform_node_js_1 = require("../../platform.node.js");
const Aes_js_1 = require("../../crypto/Aes.js");
const index_js_1 = require("../../raw/core/index.js");
class TCPIntermediateO extends tcp_js_1.TCP {
    _reserved;
    _encryptor;
    _decryptor;
    constructor() {
        super();
        this._reserved = [
            platform_node_js_1.Buffer.from('HEAD'),
            platform_node_js_1.Buffer.from('POST'),
            platform_node_js_1.Buffer.from('GET'),
            platform_node_js_1.Buffer.from('OPTI'),
            platform_node_js_1.Buffer.from('eeeeeeee', 'hex'),
        ];
    }
    async connect(ip, port, proxy, dcId) {
        await super.connect(ip, port, proxy, dcId);
        let nonce;
        if (proxy && 'secret' in proxy && 'port' in proxy && 'server' in proxy && dcId) {
            let secret = typeof proxy.secret === 'string'
                ? platform_node_js_1.Buffer.from(proxy.secret, 'hex')
                : platform_node_js_1.Buffer.from(proxy.secret);
            secret = secret.length === 17 && secret[0] === 0xdd ? secret.slice(1) : secret;
            while (true) {
                nonce = platform_node_js_1.crypto.randomBytes(64);
                if (!platform_node_js_1.Buffer.from([nonce[0]]).equals(platform_node_js_1.Buffer.from('ef', 'hex')) &&
                    !(0, helpers_js_1.includesBuffer)(this._reserved, nonce) &&
                    !nonce.slice(4, 8).equals(platform_node_js_1.Buffer.alloc(4))) {
                    nonce[56] = nonce[57] = nonce[58] = nonce[59] = 0xee;
                    break;
                }
            }
            let temp = (0, helpers_js_1.sliceBuffer)(nonce, 55, 7, -1);
            const encryptionKey = sha256(platform_node_js_1.Buffer.concat([nonce.slice(8, 40), secret]));
            const encryptionIv = nonce.slice(40, 56);
            const decryptionKey = temp.slice(0, 32);
            const decryptionIv = sha256(platform_node_js_1.Buffer.concat([temp.slice(32, 48), secret]));
            this._encryptor = (0, Aes_js_1.ctr256Cipher)(encryptionKey, encryptionIv);
            this._decryptor = (0, Aes_js_1.ctr256Cipher)(decryptionKey, decryptionIv);
            const _dcId = platform_node_js_1.Buffer.alloc(2);
            _dcId.writeInt8(dcId, 0);
            nonce = platform_node_js_1.Buffer.concat([nonce.slice(0, 60), _dcId, nonce.slice(62)]);
            nonce = platform_node_js_1.Buffer.concat([nonce.slice(0, 56), this._encryptor(nonce).slice(56, 64)]);
        }
        else {
            while (true) {
                nonce = platform_node_js_1.crypto.randomBytes(64);
                if (!platform_node_js_1.Buffer.from([nonce[0]]).equals(platform_node_js_1.Buffer.from('ef', 'hex')) &&
                    !(0, helpers_js_1.includesBuffer)(this._reserved, nonce) &&
                    !nonce.slice(4, 8).equals(platform_node_js_1.Buffer.alloc(4))) {
                    nonce[56] = nonce[57] = nonce[58] = nonce[59] = 0xee;
                    break;
                }
            }
            let temp = (0, helpers_js_1.sliceBuffer)(nonce, 55, 7, -1);
            const encryptionKey = nonce.slice(8, 40);
            const encryptionIv = nonce.slice(40, 56);
            const decryptionKey = temp.slice(0, 32);
            const decryptionIv = temp.slice(32, 48);
            this._encryptor = (0, Aes_js_1.ctr256Cipher)(encryptionKey, encryptionIv);
            this._decryptor = (0, Aes_js_1.ctr256Cipher)(decryptionKey, decryptionIv);
            nonce = platform_node_js_1.Buffer.concat([nonce.slice(0, 56), this._encryptor(nonce).slice(56, 64)]);
        }
        await super.send(nonce);
    }
    async send(data) {
        let payload = this._encryptor(platform_node_js_1.Buffer.concat([index_js_1.Primitive.Int.write(data.length), data]));
        return await super.send(payload);
    }
    async recv(_length = 0) {
        let length = await super.recv(4);
        if (!length)
            return;
        length = this._decryptor(length);
        let data = await super.recv(length.readInt32LE(0));
        if (!data)
            return;
        return this._decryptor(data);
    }
}
exports.TCPIntermediateO = TCPIntermediateO;
function sha256(data) {
    const hash = platform_node_js_1.crypto.createHash('sha256');
    hash.update(data);
    return hash.digest();
}
