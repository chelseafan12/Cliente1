"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computePasswordCheck = exports.computePasswordHash = exports.xor = void 0;
const index_js_1 = require("../raw/index.js");
const platform_node_js_1 = require("../platform.node.js");
const helpers_js_1 = require("../helpers.js");
function sha256(data) {
    return platform_node_js_1.crypto.createHash('sha256').update(data).digest();
}
function xor(a, b) {
    const length = Math.min(a.length, b.length);
    for (let i = 0; i < length; i++) {
        a[i] = a[i] ^ b[i];
    }
    return a;
}
exports.xor = xor;
function computePasswordHash(algo, password) {
    let hash1 = sha256(platform_node_js_1.Buffer.concat([algo.salt1, platform_node_js_1.Buffer.from(password, 'utf8'), algo.salt1]));
    let hash2 = sha256(platform_node_js_1.Buffer.concat([algo.salt2, hash1, algo.salt2]));
    let hash3 = platform_node_js_1.crypto.pbkdf2Sync(hash2, algo.salt1, 100000, 64, 'sha512');
    return sha256(platform_node_js_1.Buffer.concat([algo.salt2, hash3, algo.salt2]));
}
exports.computePasswordHash = computePasswordHash;
function computePasswordCheck(r, password) {
    let algo = r.currentAlgo;
    let pBytes = algo.p;
    let p = btoi(pBytes);
    let g = algo.g;
    let gBytes = itob(BigInt(g));
    let BBytes = r.srpB;
    let B = btoi(BBytes);
    let srpId = r.srpId;
    let xBytes = computePasswordHash(algo, password);
    let x = btoi(xBytes);
    let gX = (0, helpers_js_1.bigIntPow)(BigInt(g), x, p);
    let kBytes = sha256(platform_node_js_1.Buffer.concat([pBytes, gBytes]));
    let k = btoi(kBytes);
    let kGX = (0, helpers_js_1.bigIntMod)(k * gX, p);
    let aBytes;
    let a;
    let A;
    let ABytes;
    let u;
    while (true) {
        aBytes = platform_node_js_1.crypto.randomBytes(256);
        a = btoi(aBytes);
        A = (0, helpers_js_1.bigIntPow)(BigInt(g), a, p);
        ABytes = itob(A);
        u = btoi(sha256(platform_node_js_1.Buffer.concat([ABytes, BBytes])));
        if (u > BigInt(0))
            break;
    }
    let gB = (0, helpers_js_1.bigIntMod)(B - kGX, p);
    let uX = u * x;
    let aUX = a + uX;
    let S = (0, helpers_js_1.bigIntPow)(gB, aUX, p);
    let SBytes = itob(S);
    let KBytes = sha256(SBytes);
    let M1Bytes = sha256(platform_node_js_1.Buffer.concat([
        xor(sha256(pBytes), sha256(gBytes)),
        sha256(algo.salt1),
        sha256(algo.salt2),
        ABytes,
        BBytes,
        KBytes,
    ]));
    return new index_js_1.Raw.InputCheckPasswordSRP({
        srpId,
        a: ABytes,
        m1: M1Bytes,
    });
}
exports.computePasswordCheck = computePasswordCheck;
function btoi(b) {
    return (0, helpers_js_1.bufferToBigint)(b, false);
}
function itob(i) {
    return (0, helpers_js_1.bigintToBuffer)(i, 256, false);
}
