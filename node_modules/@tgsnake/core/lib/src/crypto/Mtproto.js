"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unpack = exports.pack = exports.kdf = void 0;
const platform_node_js_1 = require("../platform.node.js");
const index_js_1 = require("../errors/index.js");
const index_js_2 = require("../raw/index.js");
const MsgId_js_1 = require("../session/internals/MsgId.js");
const helpers_js_1 = require("../helpers.js");
const Aes_js_1 = require("./Aes.js");
const Logger_js_1 = require("../Logger.js");
const STORED_MSG_IDS_MAX_SIZE = 1000 * 2;
function sha256(data) {
    const hash = platform_node_js_1.crypto.createHash('sha256');
    hash.update(data);
    return hash.digest();
}
function toBytes(value) {
    const bytesArray = [];
    for (let i = 0; i < 8; i++) {
        let shift = value >> BigInt(8 * i);
        shift &= BigInt(255);
        bytesArray[i] = Number(String(shift));
    }
    return platform_node_js_1.Buffer.from(bytesArray);
}
function kdf(authKey, msgKey, outgoing) {
    const x = outgoing ? 0 : 8;
    const sha256A = sha256(platform_node_js_1.Buffer.concat([msgKey, authKey.slice(x, x + 36)]));
    const sha256B = sha256(platform_node_js_1.Buffer.concat([authKey.slice(x + 40, x + 76), msgKey]));
    const aesKey = platform_node_js_1.Buffer.concat([sha256A.slice(0, 8), sha256B.slice(8, 24), sha256A.slice(24, 32)]);
    const aesIv = platform_node_js_1.Buffer.concat([sha256B.slice(0, 8), sha256A.slice(8, 24), sha256B.slice(24, 32)]);
    return [aesKey, aesIv];
}
exports.kdf = kdf;
function pack(message, salt, sessionId, authKey, authKeyId) {
    const data = platform_node_js_1.Buffer.concat([platform_node_js_1.Buffer.concat([toBytes(salt), sessionId]), message.write()]);
    const padding = platform_node_js_1.Buffer.from(platform_node_js_1.crypto.randomBytes((0, helpers_js_1.mod)(-(data.length + 12), 16) + 12));
    const msgKeyLarge = sha256(platform_node_js_1.Buffer.concat([authKey.slice(88, 88 + 32), data, padding]));
    const msgKey = msgKeyLarge.slice(8, 24);
    const [aesKey, aesIv] = kdf(authKey, msgKey, true);
    return platform_node_js_1.Buffer.concat([
        authKeyId,
        msgKey,
        (0, Aes_js_1.ige256Encrypt)(platform_node_js_1.Buffer.concat([data, padding]), aesKey, aesIv),
    ]);
}
exports.pack = pack;
async function unpack(b, sessionId, authKey, authKeyId, storedMsgId) {
    index_js_1.SecurityCheckMismatch.check(b.read(8).equals(authKeyId), 'Provided auth key id is not equal with expected one.');
    const msgKey = b.read(16);
    const [aesKey, aesIv] = kdf(authKey, msgKey, false);
    let encrypted = b.read();
    const decrypted = (0, Aes_js_1.ige256Decrypt)(encrypted, aesKey, aesIv);
    const hash = sha256(platform_node_js_1.Buffer.concat([authKey.slice(96, 96 + 32), decrypted]));
    index_js_1.SecurityCheckMismatch.check(msgKey.equals(hash.slice(8, 24)), 'Provided msg key is not equal with expected one');
    const data = new index_js_2.BytesIO(decrypted);
    data.read(8);
    index_js_1.SecurityCheckMismatch.check(platform_node_js_1.Buffer.from(data.read(8)).equals(sessionId), 'Provided session id is not equal with expected one.');
    let message;
    try {
        message = await index_js_2.Message.read(new index_js_2.BytesIO(data.buffer.slice(16)));
    }
    catch (error) {
        Logger_js_1.Logger.error(error);
    }
    data.seek(32);
    const payload = data.read();
    const padding = payload.slice(message.length);
    index_js_1.SecurityCheckMismatch.check(padding.length >= 12 && padding.length <= 1024, 'Payload padding is lower than 12 or bigger than 1024');
    index_js_1.SecurityCheckMismatch.check((0, helpers_js_1.mod)(padding.length, 4) === 0, 'Mod of padding length with 4 is equal with zero');
    index_js_1.SecurityCheckMismatch.check((0, helpers_js_1.bigIntMod)(message.msgId, BigInt(2)) !== BigInt(0), 'Mod of msgId with 2 is not equal with zero');
    if (storedMsgId.length > STORED_MSG_IDS_MAX_SIZE) {
        storedMsgId.splice(0, Math.floor(STORED_MSG_IDS_MAX_SIZE / 2));
    }
    if (storedMsgId.length) {
        if (message.msgId < storedMsgId[0]) {
            throw new index_js_1.SecurityCheckMismatch('Msg id is lower than all of the stored values');
        }
        if (storedMsgId.includes(message.msgId)) {
            throw new index_js_1.SecurityCheckMismatch('Msg id is equal to any of the stored values');
        }
        let msgId = new MsgId_js_1.MsgId();
        let timeDiff = BigInt(message.msgId - msgId.getMsgId()) / BigInt(2 ** 32);
        if (timeDiff > BigInt(30)) {
            throw new index_js_1.SecurityCheckMismatch('Msg id belongs over 30 seconds in the future');
        }
        if (timeDiff < BigInt(-300)) {
            throw new index_js_1.SecurityCheckMismatch('Msg id belongs over 300 seconds in the past');
        }
    }
    storedMsgId.push(message.msgId);
    storedMsgId.sort((a, b) => {
        if (a > b)
            return 1;
        if (a < b)
            return -1;
        return 0;
    });
    return message;
}
exports.unpack = unpack;
