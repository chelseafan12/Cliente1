"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Decode = void 0;
/**
 * tgsnake - Telegram MTProto framework for nodejs.
 * Copyright (C) 2022 butthx <https://github.com/butthx>
 *
 * THIS FILE IS PART OF TGSNAKE
 *
 * tgsnake is a free software : you can redistribute it and/or modify
 * it under the terms of the MIT License as published.
 */
const index_js_1 = require("./index.js");
class Decode {
    constructor({ version, subVersion, dcId, fileType, id, accessHash, fileReference, url, volumeId, localId, secret, chatId, chatAccessHash, stickerSetId, stickerSetAccessHash, thumbnailSource, thumbnailFileType, thumbnailSize, fileTypeUniqueId, }) {
        this.version = version;
        this.subVersion = subVersion;
        this.dcId = dcId;
        this.fileType = fileType;
        this.id = id;
        this.accessHash = accessHash;
        this.fileReference = fileReference;
        this.url = url;
        this.volumeId = volumeId !== null && volumeId !== void 0 ? volumeId : BigInt(0);
        this.localId = localId !== null && localId !== void 0 ? localId : 0;
        this.secret = secret;
        this.chatId = chatId;
        this.chatAccessHash = chatAccessHash;
        this.stickerSetId = stickerSetId;
        this.stickerSetAccessHash = stickerSetAccessHash;
        this.thumbnailSource = thumbnailSource;
        this.thumbnailFileType = thumbnailFileType;
        this.thumbnailSize = thumbnailSize;
        this.fileTypeUniqueId = fileTypeUniqueId;
    }
    static fileId(fileId) {
        const buffer = (0, index_js_1.base64_url_decode)(fileId);
        const version = buffer[buffer.length - 1];
        const subVersion = version >= 4 ? buffer[buffer.length - 2] : 0;
        const rle = (0, index_js_1.rle_decode)(version >= 4 ? buffer.slice(0, -2) : buffer.slice(0, -1));
        const reader = new index_js_1.Reader(rle);
        let fileType = reader.readInt();
        const dcId = reader.readInt();
        const hasWebLocation = Boolean(fileType & index_js_1.FileType.WEB_LOCATION_FLAG);
        const hasFileReference = Boolean(fileType & index_js_1.FileType.FILE_REFERENCE_FLAG);
        fileType &= ~index_js_1.FileType.WEB_LOCATION_FLAG;
        fileType &= ~index_js_1.FileType.FILE_REFERENCE_FLAG;
        const FileTypes = Object.values(index_js_1.FileType).filter((v) => typeof v === 'number');
        if (!FileTypes.includes(fileType)) {
            throw new Error(`unknown fileType ${fileType} of fileId ${fileId}`);
        }
        let obj = {
            //@ts-ignore
            version,
            subVersion,
            dcId,
            fileType,
            id: BigInt(0),
            accessHash: BigInt(0),
        };
        if (hasWebLocation) {
            obj.url = reader.readString();
            obj.id = reader.readBigInt();
            obj.accessHash = reader.readBigInt();
            return new Decode(obj);
        }
        if (hasFileReference)
            obj.fileReference = reader.readBuffer();
        obj.id = reader.readBigInt();
        obj.accessHash = reader.readBigInt();
        if (index_js_1.PHOTO_TYPES.includes(fileType)) {
            obj.volumeId = reader.readBigInt();
            obj.thumbnailSource = reader.readInt();
            switch (obj.thumbnailSource) {
                case index_js_1.ThumbnailSource.LEGACY:
                    obj.secret = reader.readBigInt();
                    obj.localId = reader.readInt();
                    return new Decode(obj);
                    break;
                case index_js_1.ThumbnailSource.THUMBNAIL:
                    obj.thumbnailFileType = reader.readInt();
                    obj.thumbnailSize = String.fromCharCode(reader.readInt());
                    obj.localId = reader.readInt();
                    return new Decode(obj);
                case index_js_1.ThumbnailSource.CHAT_PHOTO_BIG:
                case index_js_1.ThumbnailSource.CHAT_PHOTO_SMALL:
                    obj.chatId = reader.readBigInt();
                    obj.chatAccessHash = reader.readBigInt();
                    obj.localId = reader.readInt();
                    return new Decode(obj);
                    break;
                case index_js_1.ThumbnailSource.STICKER_SET_THUMBNAIL:
                    obj.stickerSetId = reader.readBigInt();
                    obj.stickerSetAccessHash = reader.readBigInt();
                    obj.localId = reader.readInt();
                    return new Decode(obj);
                    break;
                default:
                    throw new Error(`unknown ThumbnailSource ${obj.thumbnailSource} of fileId ${fileId}`);
            }
        }
        return new Decode(obj);
    }
    static uniqueId(uniqueId) {
        const rle = (0, index_js_1.rle_decode)((0, index_js_1.base64_url_decode)(uniqueId));
        const reader = new index_js_1.Reader(rle);
        const fileTypeUniqueId = reader.readInt();
        switch (fileTypeUniqueId) {
            case index_js_1.FileTypeUniqueId.WEB:
                //@ts-ignore
                return new Decode({
                    fileTypeUniqueId,
                    url: reader.readString(),
                });
                break;
            case index_js_1.FileTypeUniqueId.PHOTO:
                //@ts-ignore
                return new Decode({
                    fileTypeUniqueId,
                    volumeId: reader.readBigInt(),
                    localId: reader.readInt(),
                });
                break;
            case index_js_1.FileTypeUniqueId.DOCUMENT:
                //@ts-ignore
                return new Decode({
                    fileTypeUniqueId,
                    id: reader.readBigInt(),
                });
                break;
            default:
                throw new Error(`unknown decoder for fileTypeUniqueId ${fileTypeUniqueId} of uniqueFileId ${uniqueId}`);
        }
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        const toPrint = {
            _: this.constructor.name,
        };
        for (const key in this) {
            if (this.hasOwnProperty(key)) {
                const value = this[key];
                if (!key.startsWith('_')) {
                    toPrint[key] = value;
                }
            }
        }
        return toPrint;
    }
    toJSON() {
        const toPrint = {
            _: this.constructor.name,
        };
        for (const key in this) {
            if (this.hasOwnProperty(key)) {
                const value = this[key];
                if (!key.startsWith('_')) {
                    toPrint[key] = typeof value === 'bigint' ? String(value) : value;
                }
            }
        }
        return toPrint;
    }
    toString() {
        return `[constructor of ${this.constructor.name}] ${JSON.stringify(this, null, 2)}`;
    }
}
exports.Decode = Decode;
//# sourceMappingURL=decode.js.map